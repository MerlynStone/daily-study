## 八、对象、类与面向对象编程
### 理解对象
通过new Object()创建一个新实例，或者通过字面量let o={}
- 数据属性
  - [[Conconfigurable]]:表示是否可通过 delete 删除并重新定义、是否可修改它的特性、是否可修改它的访问属性 默认true
  - [[Enumerable]]：是否可进行遍历 默认true
  - [[Writable]]：属性值是否可进行修改 默认true
  - [[Value]]：包含属性实际值 默认undefined
  - [[get]]：获取函数，在读取是执行，默认 undefined
  - [[set]]：设置函数，在设置属性是执行，默认 undefined
    ```js
    Object.defineProperty(object,key,{
        writable:false,
        value:'Nicol'
    })
    ```
- 定义多个属性
  Object.defineProperties(object,{}) 默认属性为false
- 读取属性的特性
  - Object.getOwnPropertyDesicriptor(object,key) 获取属性的描述符
- 合并属性
  - 使用Object.assign() 可接收一个模板对象和一个或多个源对象 属于浅复制
- 对象标识及相等判断  
  Object.is() 与 === 很像但它会考虑到边界值如 NaN和NaN相等
  ```js
  function recursivelyCheckEqual(x,...rest){
      return Object.is(x,rest[0]) && (rest.length<2|| recursivelyCheckEqual(...rest))
  }
  ```
- 增强对象语法  
  属性值简写，可计算属性，简写方法名
- 对象解构
  嵌套解构、部分解构 let {job:{type}}={name:'11',job:{type:'type'}}
### 创建对象
虽然使用 Object 构造函数或对象字面量的方式创建，这些方面有些不足：创建具有同样接口的多个对象需要重复编写很多代码
- 工厂函数
```js  
//  没有解决创建的对象类型问题
function createPerson(name,age,job){
    let o={}
    o.name=name;
    o.age=age;
    o.job=job;
}
```
- 构造函数
构造函数也是函数 不使用 new 则会挂载到全局  
```js
// 主要问题每个方法都会在实例上重新创建一遍
function Person(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.sayname=function(){
        console.log(this.name)
    };
}
let createPerson=new Person('name',11,'job')
// new 创建对象、并把原型内存地址__proto__指向函数的原型对象，利用函数的call方法把 指向window的绑定对象this指向了obj，利用函数返回对象obj
function myNew(fn, ...args) {
//声明对象
    const obj = new Object()
    //将构造函数原型上的方法附到我们率先导出的对向上
    obj.__proto__ = fn.prototype
    //执行构造函数并把this指向更改为obj
    let res = fn.call(obj,...args)
    //return出去
    return typeof res == 'object' ? res || obj : obj
}

```
### 原型模式
每个函数都会创建一个 prototype 属性是对象，包含由特定引用
类型的实例共享的属性和方法(原型的主要问题)
- 理解原型
  - prototype 与 __proto__  区别补充  

  let fun=function(){} fun.prototype constructor(存在于原型属性)  
  Object.getPrototypeOf() 获取对象的原型  
  用Object.create() 代替Object.setPrototypeOf()
  ```js
  let biped={numlegs:2}
  let person=Object.create(biped) //创建新对象并绑定原型
  person.name='mat'
  person//{numlegs:2,name:'mat'}
  Object.getPrototypeOf(person)===biped
  // create 底层
  Object.create =  function (o) {
    var F = function () {};
    F.prototype = o;
    return new F();
  };
  ```
- 原型层级  
  先去实例上找属性，找不到去原型找；实例属性会覆盖原型属性
- 原型和 in 操作符  
  - 直接 for in 使用，或者 key in object 会访问原型及实例
  - hasOwnProperty() 属性存在实例上才会返回 true 判断：in 返回 false hasOwnProperty 返回true 是原型
- 属性枚举顺序
  - for - in 循环，Object.keys() 返回顺序不确定
  - Object.getOwnPropertyNames()，Object.getOwnPropertySymbols()，Object.assign() 升序枚举数值键
### 迭代对象
Object.keys() 返回 key 数组   
Object.entires() 返回键值对数组 可实现浅复制   
重写原型注意恢复 constructor 属性 使用Object.defineProperty(obj.prototype,'constructor',{})
### 继承
构造函数、原型与实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身就有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数；这样实例与原型之间构造了一条原型链。
```js
function SuperType(){
  this.property=true
}
Super.prototype.getSuperValue=function(){
  return this.value
}
function subType(){
  this.subproperty=false
}
// 继承Supertype
SubType.prototype=new SuperType()
subType.prototype.getSubValue=function(){
  return this.subproperty
}
let instance=new SubType()
console.log(instance.getSuperValue())  // true
// SubType继承 SuperType，SuperType 继承 Object
// instance.tostring() 其实是执行Object中的方法
```
- 原型与继承关系
  一种是通过 instanceof 操作符 如果实例的原型链中出现相应的构造函数则返回true    
  另一种即使使用 isPrototypeOf()方法 原型链中包含这个原型则返回true
- 子类有时需要覆盖父类的方法或者增加父类没有的方法，则必须在原型链赋值只会再添加到原型上
- 盗用构造函数
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生式组合继承
### 类
- 类的定义
  ```js
  class Bar{} // 类声明
  let Baz=class{}  // 类表达式
  // 与函数表达式类似，类表达式在他们被赋值前不能引用，类定义没有提示，类受块作用域的限制，函数受函数作用域的限制
  ```
- 类构造函数  
   ```js
  class Bar{
    constructor(){
      console.log('Bar')
      this.color='red'
    }
  } // 类声明
  let bar=new Bar() // Bar
  bar.color  // red
  ```
- 实例、原型和类成员
每次通过 new 调用类标识符，都会执行 constructor 构造函数，constructor 中成员不会在原型上共享
 ```js
  class Bar{
    constructor(){
      console.log('Bar')
      this.color=new String('red')
    }
  } // 类声明
  let bar=new Bar() // Bar
  let bar2=new Bar() // Bar
  bar.color === bar2.color
  bar.color  // red
  ```
- 继承
  ```js
  class Bar extends Baz{} // 继承类
  class Bar extends Baz {
    constructor(){
      super()  // 派生类中使用 引用他们的原型 静态中使用引用静态方法 不能在 super 之前使用 this 
    }
  } // 继承Baz
  ```