## 八、对象、类与面向对象编程
### 理解对象
通过new Object()创建一个新实例，或者通过字面量let o={}
- 数据属性
  - [[Conconfigurable]]:表示是否可通过 delete 删除并重新定义、是否可修改它的特性、是否可修改它的访问属性 默认true
  - [[Enumerable]]：是否可进行遍历 默认true
  - [[Writable]]：属性值是否可进行修改 默认true
  - [[Value]]：包含属性实际值 默认undefined
  - [[get]]：获取函数，在读取是执行，默认 undefined
  - [[set]]：设置函数，在设置属性是执行，默认 undefined
    ```js
    Object.defineProperty(object,key,{
        writable:false,
        value:'Nicol'
    })
    ```
- 定义多个属性
  Object.defineProperties(object,{}) 默认属性为false
- 读取属性的特性
  - Object.getOwnPropertyDesicriptor(object,key) 获取属性的描述符
- 合并属性
  - 使用Object.assign() 可接收一个模板对象和一个或多个源对象 属于浅复制
- 对象标识及相等判断  
  Object.is() 与 === 很像但它会考虑到边界值如 NaN和NaN相等
  ```js
  function recursivelyCheckEqual(x,...rest){
      return Object.is(x,rest[0]) && (rest.length<2|| recursivelyCheckEqual(...rest))
  }
  ```
- 增强对象语法  
  属性值简写，可计算属性，简写方法名
- 对象解构
  嵌套解构、部分解构 let {job:{type}}={name:'11',job:{type:'type'}}
### 创建对象
虽然使用 Object 构造函数或对象字面量的方式创建，这些方面有些不足：创建具有同样接口的多个对象需要重复编写很多代码
- 工厂函数
```js  
//  没有解决创建的对象类型问题
function createPerson(name,age,job){
    let o={}
    o.name=name;
    o.age=age;
    o.job=job;
}
```
- 构造函数
构造函数也是函数 不使用 new 则会挂载到全局  
```js
// 主要问题每个方法都会在实例上重新创建一遍
function Person(name,age,job){
    this.name=name;
    this.age=age;
    this.job=job;
    this.sayname=function(){
        console.log(this.name)
    };
}
let createPerson=new Person('name',11,'job')
// new 创建对象、并把原型内存地址__proto__指向函数的原型对象，利用函数的call方法把 指向window的绑定对象this指向了obj，利用函数返回对象obj
function myNew(fn, ...args) {
//声明对象
    const obj = new Object()
    //将构造函数原型上的方法附到我们率先导出的对向上
    obj.__proto__ = fn.prototype
    //执行构造函数并把this指向更改为obj
    let res = fn.call(obj,...args)
    //return出去
    return typeof res == 'object' ? res || obj : obj
}

```
### 原型模式
每个函数都会创建一个 prototype 属性是对象，包含由特定引用
类型的实例共享的属性和方法(原型的主要问题)
- 理解原型
  - prototype 与 __proto__  区别补充  

  let fun=function(){} fun.prototype constructor(存在于原型属性)  
  Object.getPrototypeOf() 获取对象的原型  
  用Object.create() 代替Object.setPrototypeOf()
  ```js
  let biped={numlegs:2}
  let person=Object.create(biped) //创建新对象并绑定原型
  person.name='mat'
  person//{numlegs:2,name:'mat'}
  Object.getPrototypeOf(person)===biped
  // create 底层
  Object.create =  function (o) {
    var F = function () {};
    F.prototype = o;
    return new F();
  };
  ```
- 原型层级  
  先去实例上找属性，找不到去原型找；实例属性会覆盖原型属性
- 原型和 in 操作符  
  - 直接 for in 使用，或者 key in object 会访问原型及实例
  - hasOwnProperty() 属性存在实例上才会返回 true 判断：in 返回 false hasOwnProperty 返回true 是原型
- 属性枚举顺序
  - for - in 循环，Object.keys() 返回顺序不确定
  - Object.getOwnPropertyNames()，Object.getOwnPropertySymbols()，Object.assign() 升序枚举数值键
### 迭代对象
Object.keys() 返回 key 数组   
Object.entires() 返回键值对数组 可实现浅复制   
重写原型注意恢复 constructor 属性 使用Object.defineProperty(obj.prototype,'constructor',{})