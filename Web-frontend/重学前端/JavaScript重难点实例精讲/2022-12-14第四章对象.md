## 第四章 对象
### 4.1.1对象的属性和访问方法
- 1数据属性  
  数据具有4个描述其行为特性：修改属性使用Object.defineProperty(target,property,config)函数
  - [[Configurable]]默认true 是否可删除重新定义
  - [[Enumerable]] 默认true 是否可枚举 通过for in
  - [[Writable]] 默认true 属性可被修复
  - [[Value]] 属性的真实值 默认undefined
- 2访问器属性有4个描述其行为特性： 修改属性使用Object.defineProperty(target,property,config)函数
  - [[Configurable]]默认true 是否可删除重新定义
  - [[Enumerable]] 默认true 是否可枚举 通过for in
  - [[Get]] 读取属性值 一般为getter 默认undefine
  - [[Set]] 设置属性值 一般为setter 默认undefine
### 4.1.2 属性的访问方式
- 使用 . 访问属性
- 使用 [] 访问属性
### 4.2 创建对象
- 1基于Object()构造函数 var obj=new Object() obj.key=val
- 2基于字面量 var obj={key:val}
- 3基于工厂方法模式
  ```js
  function createP(name,age){
      let o={}
      o.name=name
      o.age=age
      return o;
  }
  ```
  - 4基于构造函数
  ```js
  function CreateP(name,age){
      this.name=name
      this.age=age
  }
  new CreateP()
  ```
- 5基于原型对象模式
  ```js
  function CreateP(name,age){
      CreateP.prototype.name='name'
  }
  new CreateP()
  ```
- 6构造函数和原型混合模式
- 7基于动态原型模式
### 4.3 对象克隆
简单类型传值，复杂数据类型传址  
深浅拷贝
- 深拷贝 
  - json序列化和反序列化：无法实现函数、RegExp、Date等特殊对象的克隆，对象的constructor会被抛弃，原型链关系断裂，对象中存在循环引用会抛出异常
  - 自定义实现深拷贝：所有的数据类型、对象原型、循环引用
  - JQuery 的$.extend()  没有解决循环引用的问题
  - 三方 Lodash
### 4.4 原型对象
- 4.4.1 原型对象、构造函数、实例之间的关系   
  - 每个函数在创建的时候都会被赋予一个prototype属性，在默认情况下所有的原型对象都会增加一个constructor属性，指向prototype属性所在的函数，即构造函数
  - 当通过new操作符调用构造函数创建一个实例时，实例具有一个__proto__属性，指向构造函数的原型对象，因此__proto__属性可以看做是一个链接实例与构造函数的原型对象的桥梁
  - 解释：构造函数P有个prototype属性，指向P的原型对象，原型对象中有constructor属性和其他原型对象的属性，其他constructor属性指向构造函数本身；同new创建的实例都具有__proto__属性及[[prototype]]指向的是P的原型对象
- 实例属性的读取顺序
  - 先实例对象，没有寻找原型对象，再没有向上原型链查找，直到找到Object.prototype.__proto__为null时返回undefined；前者都会覆盖后者
- 原型链
  - 原型链的特点：会向上查找，前者覆盖后者；查找链路长对性能有影响
- 属性区分
  - 通过 hasOwnPrototype() 函数判断是否为实例
- 内置构造函数的__proto__都指向Function.prototype
- __proto__属性
### 4.5 继承
```js
function Animal(){
  // 实例函数及实例对象
  this.name=name||'动物'
  this.type=type
}
// 原型方法
Animal.prototype.eat=function(food){
  console.log(this.name+'eat'+food)
}
```